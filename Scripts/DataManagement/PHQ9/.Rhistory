result.func=result.vec
for(i in 1:29)
{
if(test.vec[i]>=thresh.low & test.vec[i]<=thresh.high)
{result.func[i]=grade.id.val}
else
{result.func[i]=result.func[i]}
}
return(result.func)
}
num.letter=function(id.vec)
{
len=length(id.vec)
grade=rep(0, times=len)
for(i in 1:len)
{
if(id.vec[i]==1){grade[i]="A"}
if(id.vec[i]==2){grade[i]="A-"}
if(id.vec[i]==3){grade[i]="B+"}
if(id.vec[i]==4){grade[i]="B"}
if(id.vec[i]==5){grade[i]="B-"}
if(id.vec[i]==6){grade[i]="C+"}
if(id.vec[i]==7){grade[i]="C"}
if(id.vec[i]==8){grade[i]="D"}
else{grade[i]="F"}
}
return(grade)
}
mat.test=function(mat, t.val)
{
len=dim(mat)[1]
for(i in 1:len)
{
if((mat[i,1]<=t.val)&(mat[i,2]<=t.val)&(mat[i,3]<=t.val)){out=0}
if((mat[i,1]>t.val)&(mat[i,2]>t.val)&(mat[i,3]>t.val)){out=3}
if(((mat[i,1]>t.val)&(mat[i,2]<=t.val)&(mat[i,3]<=t.val))|
((mat[i,1]<=t.val)&(mat[i,2]>t.val)&(mat[i,3]<=t.val))|
((mat[i,1]<=t.val)&(mat[i,2]<=t.val)&(mat[i,3]>t.val))){out=1}
if(((mat[i,1]>t.val)&(mat[i,2]>t.val)&(mat[i,3]<=t.val))|
((mat[i,1]>t.val)&(mat[i,2]<=t.val)&(mat[i,3]>t.val))|
((mat[i,1]<=t.val)&(mat[i,2]>t.val)&(mat[i,3]>t.val))|
((mat[i,1]>t.val)&(mat[i,2]>t.val)&(mat[i,3]<=t.val))|
((mat[i,1]>t.val)&(mat[i,2]<=t.val)&(mat[i,3]>t.val))|
((mat[i,1]<=t.val)&(mat[i,2]>t.val)&(mat[i,3]>t.val))){out=2}
}
return(out)
}
grade.id.num=NA
p1.grade.id.num=NA
p2.grade.id.num=NA
p3.grade.id.num=NA
pg$grade.id.num=grade.id.num
pg$p1.grade.id.num=p1.grade.id.num
pg$p2.grade.id.num=p2.grade.id.num
pg$p3.grade.id.num=p3.grade.id.num
out=rep(0, times=29)
#Final Grade ID Number
after.A=id.grade(pg$F, out,  92, 100, 1)
after.Aminus=id.grade(pg$F, after.A, 90, 91.99, 2)
after.Bplus=id.grade(pg$F, after.Aminus, 88, 89.99, 3)
after.B=id.grade(pg$F, after.Bplus, 82, 87.99, 4)
after.Bminus=id.grade(pg$F, after.B, 80, 81.99, 5)
after.Cplus=id.grade(pg$F, after.Bminus, 78, 79.99, 6)
after.C=id.grade(pg$F, after.Cplus, 70, 77.99, 7)
after.D=id.grade(pg$F, after.C, 60, 69.99, 8)
after.F=id.grade(pg$F, after.D, 0, 59.99, 9)
pg$grade.id.num=after.F
out=rep(0, times=29)
#P1 Grade Id Number
p1.after.A=id.grade(pg$P1, out,  92, 100, 1)
p1.after.Aminus=id.grade(pg$P1, p1.after.A, 90, 91.99, 2)
p1.after.Bplus=id.grade(pg$P1, p1.after.Aminus, 88, 89.99, 3)
p1.after.B=id.grade(pg$P1, p1.after.Bplus, 82, 87.99, 4)
p1.after.Bminus=id.grade(pg$P1, p1.after.B, 80, 81.99, 5)
p1.after.Cplus=id.grade(pg$P1, p1.after.Bminus, 78, 79.99, 6)
p1.after.C=id.grade(pg$P1, p1.after.Cplus, 70, 77.99, 7)
p1.after.D=id.grade(pg$P1, p1.after.C, 60, 69.99, 8)
p1.after.F=id.grade(pg$P1, p1.after.D, 0, 59.99, 9)
pg$p1.grade.id.num=p1.after.F
out=rep(0, times=29)
#P2 Grade Id Number
p2.after.A=id.grade(pg$P2, out,  92, 100, 1)
p2.after.Aminus=id.grade(pg$P2, p2.after.A, 90, 91.99, 2)
p2.after.Bplus=id.grade(pg$P2, p2.after.Aminus, 88, 89.99, 3)
p2.after.B=id.grade(pg$P2, p2.after.Bplus, 82, 87.99, 4)
p2.after.Bminus=id.grade(pg$P2, p2.after.B, 80, 81.99, 5)
p2.after.Cplus=id.grade(pg$P2, p2.after.Bminus, 78, 79.99, 6)
p2.after.C=id.grade(pg$P2, p2.after.Cplus, 70, 77.99, 7)
p2.after.D=id.grade(pg$P2, p2.after.C, 60, 69.99, 8)
p2.after.F=id.grade(pg$P2, p2.after.D, 0, 59.99, 9)
pg$p2.grade.id.num=p2.after.F
#P3 Grade Id Number
p3.after.A=id.grade(pg$P3, out,  92, 100, 1)
p3.after.Aminus=id.grade(pg$P3, p3.after.A, 90, 91.99, 2)
p3.after.Bplus=id.grade(pg$P3, p3.after.Aminus, 88, 89.99, 3)
p3.after.B=id.grade(pg$P3, p3.after.Bplus, 82, 87.99, 4)
p3.after.Bminus=id.grade(pg$P3, p3.after.B, 80, 81.99, 5)
p3.after.Cplus=id.grade(pg$P3, p3.after.Bminus, 78, 79.99, 6)
p3.after.C=id.grade(pg$P3, p3.after.Cplus, 70, 77.99, 7)
p3.after.D=id.grade(pg$P3, p3.after.C, 60, 69.99, 8)
p3.after.F=id.grade(pg$P3, p3.after.D, 0, 59.99, 9)
pg$p3.grade.id.num=p3.after.F
pg$p1.letter=NA
pg$p2.letter=NA
pg$p3.letter=NA
pg=Period_Grades
id.grade=function(test.vec, result.vec, thresh.low, thresh.high, grade.id.val)
{
result.func=result.vec
for(i in 1:29)
{
if(test.vec[i]>=thresh.low & test.vec[i]<=thresh.high)
{result.func[i]=grade.id.val}
else
{result.func[i]=result.func[i]}
}
return(result.func)
}
num.letter=function(id.vec)
{
len=length(id.vec)
grade=rep(0, times=len)
for(i in 1:len)
{
if(id.vec[i]==1){grade[i]="A"}
if(id.vec[i]==2){grade[i]="A-"}
if(id.vec[i]==3){grade[i]="B+"}
if(id.vec[i]==4){grade[i]="B"}
if(id.vec[i]==5){grade[i]="B-"}
if(id.vec[i]==6){grade[i]="C+"}
if(id.vec[i]==7){grade[i]="C"}
if(id.vec[i]==8){grade[i]="D"}
else{grade[i]="F"}
}
return(grade)
}
mat.test=function(mat, t.val)
{
len=dim(mat)[1]
for(i in 1:len)
{
if((mat[i,1]<=t.val)&(mat[i,2]<=t.val)&(mat[i,3]<=t.val)){out=0}
if((mat[i,1]>t.val)&(mat[i,2]>t.val)&(mat[i,3]>t.val)){out=3}
if(((mat[i,1]>t.val)&(mat[i,2]<=t.val)&(mat[i,3]<=t.val))|
((mat[i,1]<=t.val)&(mat[i,2]>t.val)&(mat[i,3]<=t.val))|
((mat[i,1]<=t.val)&(mat[i,2]<=t.val)&(mat[i,3]>t.val))){out=1}
if(((mat[i,1]>t.val)&(mat[i,2]>t.val)&(mat[i,3]<=t.val))|
((mat[i,1]>t.val)&(mat[i,2]<=t.val)&(mat[i,3]>t.val))|
((mat[i,1]<=t.val)&(mat[i,2]>t.val)&(mat[i,3]>t.val))|
((mat[i,1]>t.val)&(mat[i,2]>t.val)&(mat[i,3]<=t.val))|
((mat[i,1]>t.val)&(mat[i,2]<=t.val)&(mat[i,3]>t.val))|
((mat[i,1]<=t.val)&(mat[i,2]>t.val)&(mat[i,3]>t.val))){out=2}
}
return(out)
}
grade.id.num=NA
p1.grade.id.num=NA
p2.grade.id.num=NA
p3.grade.id.num=NA
pg$grade.id.num=grade.id.num
pg$p1.grade.id.num=p1.grade.id.num
pg$p2.grade.id.num=p2.grade.id.num
pg$p3.grade.id.num=p3.grade.id.num
out=rep(0, times=29)
#Final Grade ID Number
after.A=id.grade(pg$F, out,  92, 100, 1)
after.Aminus=id.grade(pg$F, after.A, 90, 91.99, 2)
after.Bplus=id.grade(pg$F, after.Aminus, 88, 89.99, 3)
after.B=id.grade(pg$F, after.Bplus, 82, 87.99, 4)
after.Bminus=id.grade(pg$F, after.B, 80, 81.99, 5)
after.Cplus=id.grade(pg$F, after.Bminus, 78, 79.99, 6)
after.C=id.grade(pg$F, after.Cplus, 70, 77.99, 7)
after.D=id.grade(pg$F, after.C, 60, 69.99, 8)
after.F=id.grade(pg$F, after.D, 0, 59.99, 9)
pg$grade.id.num=after.F
out=rep(0, times=29)
#P1 Grade Id Number
p1.after.A=id.grade(pg$P1, out,  92, 100, 1)
p1.after.Aminus=id.grade(pg$P1, p1.after.A, 90, 91.99, 2)
p1.after.Bplus=id.grade(pg$P1, p1.after.Aminus, 88, 89.99, 3)
p1.after.B=id.grade(pg$P1, p1.after.Bplus, 82, 87.99, 4)
p1.after.Bminus=id.grade(pg$P1, p1.after.B, 80, 81.99, 5)
p1.after.Cplus=id.grade(pg$P1, p1.after.Bminus, 78, 79.99, 6)
p1.after.C=id.grade(pg$P1, p1.after.Cplus, 70, 77.99, 7)
p1.after.D=id.grade(pg$P1, p1.after.C, 60, 69.99, 8)
p1.after.F=id.grade(pg$P1, p1.after.D, 0, 59.99, 9)
pg$p1.grade.id.num=p1.after.F
out=rep(0, times=29)
#P2 Grade Id Number
p2.after.A=id.grade(pg$P2, out,  92, 100, 1)
p2.after.Aminus=id.grade(pg$P2, p2.after.A, 90, 91.99, 2)
p2.after.Bplus=id.grade(pg$P2, p2.after.Aminus, 88, 89.99, 3)
p2.after.B=id.grade(pg$P2, p2.after.Bplus, 82, 87.99, 4)
p2.after.Bminus=id.grade(pg$P2, p2.after.B, 80, 81.99, 5)
p2.after.Cplus=id.grade(pg$P2, p2.after.Bminus, 78, 79.99, 6)
p2.after.C=id.grade(pg$P2, p2.after.Cplus, 70, 77.99, 7)
p2.after.D=id.grade(pg$P2, p2.after.C, 60, 69.99, 8)
p2.after.F=id.grade(pg$P2, p2.after.D, 0, 59.99, 9)
pg$p2.grade.id.num=p2.after.F
#P3 Grade Id Number
p3.after.A=id.grade(pg$P3, out,  92, 100, 1)
p3.after.Aminus=id.grade(pg$P3, p3.after.A, 90, 91.99, 2)
p3.after.Bplus=id.grade(pg$P3, p3.after.Aminus, 88, 89.99, 3)
p3.after.B=id.grade(pg$P3, p3.after.Bplus, 82, 87.99, 4)
p3.after.Bminus=id.grade(pg$P3, p3.after.B, 80, 81.99, 5)
p3.after.Cplus=id.grade(pg$P3, p3.after.Bminus, 78, 79.99, 6)
p3.after.C=id.grade(pg$P3, p3.after.Cplus, 70, 77.99, 7)
p3.after.D=id.grade(pg$P3, p3.after.C, 60, 69.99, 8)
p3.after.F=id.grade(pg$P3, p3.after.D, 0, 59.99, 9)
pg$p3.grade.id.num=p3.after.F
pg$F.letter=NA
pg$p1.letter=NA
pg$p2.letter=NA
pg$p3.letter=NA
pg$F.letter=num.letter(pg$F)
pg$F.letter=num.letter(pg$grade.id.num)
num.letter=function(id.vec)
{
len=length(id.vec)
grade=rep(0, times=len)
for(i in 1:len)
{
if(id.vec[i]==1){grade[i]="A"}
if(id.vec[i]==2){grade[i]="A-"}
if(id.vec[i]==3){grade[i]="B+"}
if(id.vec[i]==4){grade[i]="B"}
if(id.vec[i]==5){grade[i]="B-"}
if(id.vec[i]==6){grade[i]="C+"}
if(id.vec[i]==7){grade[i]="C"}
if(id.vec[i]==8){grade[i]="D"}
if(id.vec[i]==9){grade[i]="F"}
}
return(grade)
}
pg$F.letter=num.letter(pg$grade.id.num)
pg$p1.letter=num.letter(p2.grade.id.num)
pg$p1.letter=num.letter(p1.grade.id.num)
pg$p1.letter=num.letter(pg$p1.grade.id.num)
pg$p2.letter=num.letter(pg$p2.grade.id.num)
pg$p3.letter=num.letter(pg$p3.grade.id.num)
write.csv(pg, file = "Period_Grades_Altered.csv")
View(pg)
dat=read.csv(file.choose())
dat=read.csv(file.choose())
summary(dat)
View(dat)
dat=read.csv(file.choose())
summary(dat)
t.test(dat$Course.Grade, dat$Recitation.Grade, paired = TRUE, alternative = "two.sided")
t.test(dat$Course.Grade, dat$Recitation.Grade, paired = TRUE, alternative = "two.sided", conf.level = 0.999)
var.test(dat$Course.Grade, dat$Recitation.Grade, ratio = 1, alternative = "two.sided", conf.level = 0.95)
var.test(dat$Course.Grade, dat$Recitation.Grade, ratio = 1, alternative = "two.sided", conf.level = 0.999)
var.test(dat$Course.Grade, dat$Recitation.Grade, ratio = 1, alternative = "two.sided", conf.level = 0.9)
var(dat$Course.Grade)
var(dat$Recitation.Grade)
var.test(dat$Course.Grade, dat$Recitation.Grade, ratio = var.course/var.rec, alternative = "two.sided", conf.level = 0.9)
var.course=var(dat$Course.Grade)
var.rec=var(dat$Recitation.Grade)
var.test(dat$Course.Grade, dat$Recitation.Grade, ratio = var.course/var.rec, alternative = "two.sided", conf.level = 0.9)
var.test(dat$Course.Grade, dat$Recitation.Grade, ratio = 1, alternative = "two.sided", conf.level = 0.1)
var.test(dat$Course.Grade, dat$Recitation.Grade, ratio = 1, alternative = "two.sided", conf.level = 0.999)
out=var.test(dat$Course.Grade, dat$Recitation.Grade, ratio = 1, alternative = "two.sided", conf.level = 0.999)
out$conf.int
for(i in 2:7)
{
length=1*10^i
norm=rnorm(length, 5, 4)
csq=rchisq(length, 3)
dist=0.3*norm+0.7*csq
hist(dist, bins=i/10)
}
id=1:100
####	CVInitialSetups.R	 ####
#-------------------------------------------------------------------------#
####	Description:	 ####
# This script
# - performs a Meta-analysis over the CV data partitions to determine a proper subset of K-values to use, and what possible N.Obs.train exist
# - performs an accuracy analysis to determine the optimal convergence threshold for the Pscore classification algorithm
# - Calculates the full P-score algorithm weights for the full data set, and the associate outcomes.
####	Script Dependencies	 ####
# Package Dependencies:
library(ggplot2)
library(reshape)
# Set Working Directory
WD="/Users/lee/Documents/GitHub/ProbabilisticScoring/Scripts/cvAnalysis"
setwd(WD)
# Data Dependencies:
# PHQ9 Data
source(file = "/Users/lee/Documents/GitHub/ProbabilisticScoring/Scripts/DataManagement/PHQ9/phq9DataSubsetImport.R")
# source(file="phq9DataSubsetImport.R")
# Variable Dependencies:
set.seed(123)
options(warn = -1)
# File Dependencies
## functions:
# Weight Calculations
source(file = "/Users/lee/Documents/GitHub/ProbabilisticScoring/Scripts/cvAnalysis/functionsWeightCalculations.R")
# source(file="functionsWeightCalculations.R")
# Probabilistic Score Calculations
source(file = "/Users/lee/Documents/GitHub/ProbabilisticScoring/Scripts/cvAnalysis/functionsProbScoreCalc.R")
# source(file="functionsProbScoreCalc.R")
# Scoring Analysis
source(file="/Users/lee/Documents/GitHub/ProbabilisticScoring/Scripts/cvAnalysis/functionsScoringAnalysis.R")
# source(file="functionsScoringAnalysis.R")
#-------------------------------------------------------------------------#
#-------------------------------------------------------------------------#
####	Begin Script	 ####
#-------------------------------------------------------------------------#
#-------------------------------------------------------------------------#
####	CVInitialSetups.R	 ####
#-------------------------------------------------------------------------#
####	Description:	 ####
# This script
# - performs a Meta-analysis over the CV data partitions to determine a proper subset of K-values to use, and what possible N.Obs.train exist
# - performs an accuracy analysis to determine the optimal convergence threshold for the Pscore classification algorithm
# - Calculates the full P-score algorithm weights for the full data set, and the associate outcomes.
####	Script Dependencies	 ####
# Package Dependencies:
library(ggplot2)
library(reshape)
# Set Working Directory
WD="/Users/lee/Documents/GitHub/ProbabilisticScoring/Scripts/cvAnalysis"
setwd(WD)
# Data Dependencies:
# PHQ9 Data
source(file = "/Users/lee/Documents/GitHub/ProbabilisticScoring/Scripts/DataManagement/PHQ9/phq9DataSubsetImport.R")
# source(file="phq9DataSubsetImport.R")
# Variable Dependencies:
set.seed(123)
options(warn = -1)
# File Dependencies
## functions:
# Weight Calculations
source(file = "/Users/lee/Documents/GitHub/ProbabilisticScoring/Scripts/cvAnalysis/functionsWeightCalculations.R")
# source(file="functionsWeightCalculations.R")
# Probabilistic Score Calculations
source(file = "/Users/lee/Documents/GitHub/ProbabilisticScoring/Scripts/cvAnalysis/functionsProbScoreCalc.R")
# source(file="functionsProbScoreCalc.R")
# Scoring Analysis
source(file="/Users/lee/Documents/GitHub/ProbabilisticScoring/Scripts/cvAnalysis/functionsScoringAnalysis.R")
# source(file="functionsScoringAnalysis.R")
#-------------------------------------------------------------------------#
#-------------------------------------------------------------------------#
####	Begin Script	 ####
#-------------------------------------------------------------------------#
#-------------------------------------------------------------------------#
####	Sample-length Analysis Train only ####
len.train=c()
N=2495
k=5:2490
len.k=length(k)
for(i in 1:len.k){
len.train[i]=floor(N/(k[i]))*(k[i]-1)
}
min.train=min(len.train)
min.index.train=which(len.train==min.train)
max.train=max(len.train)
max.index.train=which(len.train==max.train)
uniq.len.train=unique(len.train)
index.len.train=list()
len.train.uniq.k=length(uniq.len.train)
for(i in 1:len.train.uniq.k){
index.len.train[[i]]=which(len.train==sort(uniq.len.train)[i])
}
set.train.info=list()
k.sets.train=list()
N.obs.training.set=c()
for(i in 1:len.train.uniq.k){
N.obs.training.set[[i]]=sort(uniq.len.train)[i]
k.sets.train[[i]]=k[index.len.train[[i]]]
}
set.train.info=list(N.obs.training.set, k.sets.train)
even.probs.vector.train=c()
for(i in 1:len.train.uniq.k){
even.probs.vector.train[i]=set.train.info[[2]][[i]][1]
}
df.train.set.info=data.frame(as.numeric(even.probs.vector.train),
N.obs.training.set)
colnames(df.train.set.info)=c("df.k.sets.train", "N.obs.training.set")
####	Sample-Length Analysis  test/train####
len.train=c()
len.test=c()
N=2495
k=5:2490
len.k=length(k)
for(i in 1:len.k){
len.train[i]=floor(N/(k[i]))*(k[i]-1)
}
for(i in 1:len.k){
len.test[i]=floor(N/(k[i]))
}
min.train=min(len.train)
min.index.train=which(len.train==min.train)
min.test=min(len.test)
min.index.test=which(len.test==min.test)
max.train=max(len.train)
max.index.train=which(len.train==max.train)
max.test=max(len.test)
max.index.test=which(len.test==max.test)
uniq.len.train=unique(len.train)
uniq.len.test=unique(len.test)
index.len.train=list()
index.len.test=list()
len.train.uniq.k=length(uniq.len.train)
len.test.uniq.k=length(uniq.len.test)
for(i in 1:len.train.uniq.k){
index.len.train[[i]]=which(len.train==sort(uniq.len.train)[i])
}
for(i in 1:len.test.uniq.k){
index.len.test[[i]]=which(len.test==sort(uniq.len.test)[i])
}
set.train.info=list()
k.sets.train=list()
N.obs.training.set=c()
set.test.info=list()
k.sets.test=list()
N.obs.testing.set=c()
for(i in 1:len.train.uniq.k){
N.obs.training.set[[i]]=sort(uniq.len.train)[i]
k.sets.train[[i]]=k[index.len.train[[i]]]
}
for(i in 1:len.test.uniq.k){
N.obs.testing.set[[i]]=sort(uniq.len.test)[i]
k.sets.test[[i]]=k[index.len.test[[i]]]
}
set.train.info=list(N.obs.training.set, k.sets.train)
set.test.info=list(N.obs.testing.set, k.sets.test)
even.probs.vector.train=c()
even.probs.vector.test=c()
for(i in 1:len.train.uniq.k){
even.probs.vector.train[i]=set.train.info[[2]][[i]][1]
}
for(i in 1:len.test.uniq.k){
even.probs.vector.test[i]=set.test.info[[2]][[i]][1]
}
df.train.set.info=data.frame(as.numeric(even.probs.vector.train),
N.obs.training.set)
colnames(df.train.set.info)=c("df.k.sets.train", "N.obs.training.set")
df.test.set.info=data.frame(as.numeric(even.probs.vector.test),
N.obs.testing.set)
colnames(df.test.set.info)=c("df.k.sets.test", "N.obs.testing.set")
k.training.values=sort(df.train.set.info$df.k.sets.train)[1:10]
df.set.info=data.frame(k, len.train, len.test)
df.temp=df.set.info
df.temp.ones=subset(df.temp, len.test==1)
(min.k.one=df.temp.ones[which.min(df.temp.ones$k),])
(max.k.one=df.temp.ones[which.max(df.temp.ones$k),])
df.temp.twos=subset(df.temp, len.test==2)
(min.k.two=df.temp.twos[which.min(df.temp.twos$k),])
(max.k.two=df.temp.twos[which.max(df.temp.twos$k),])
p=ggplot(df.set.info, aes(x=k))+
geom_point(aes(y=len.train),
color="darkslategrey")+
geom_point(aes(y=len.test),
color="cornflowerblue")+
geom_segment(aes(x=0, xend=832, y=1662, yend=1662,
color="darkgoldenrod",
linetype="twodash"))+
geom_segment(aes(x=832, xend=832, y=2, yend=1662,
color="darkgoldenrod",
linetype="twodash"))+
geom_point(aes(x=832, y=1662,
color="darkgoldenrod"))+
geom_point(aes(x=0, y=1662,
color="darkgoldenrod"))+
geom_point(aes(x=832, y=2,
color="darkgoldenrod"))+
geom_segment(aes(x=0, xend=832, y=1662, yend=1662,
color="darkgoldenrod",
linetype="twodash"))+
geom_segment(aes(x=1247, xend=1247, y=1249, yend=2492,
color="darkgoldenrod",
linetype="twodash"))+
geom_segment(aes(x=0, xend=1247, y=2492, yend=2492,
color="darkgoldenrod",
linetype="twodash"))+
geom_point(aes(x=1247, y=2492,color="darkgoldenrod"))+
geom_point(aes(x=0, y=2492,color="darkgoldenrod"))+
geom_point(aes(x=1247, y=0,color="darkgoldenrod"))+
geom_segment(aes(x=0, xend=1248, y=1247, yend=1247,
color="firebrick",
linetype="longdash"))+
geom_segment(aes(x=2490, xend=2490, y=1, yend=2489,
color="firebrick",
linetype="longdash"))+
geom_point(aes(x=2490, y=2489,
color="firebrick"))+
geom_point(aes(x=0, y=2489,
color="firebrick"))+
geom_point(aes(x=1248, y=1,
color="firebrick"))+
geom_segment(aes(x=0, xend=1248, y=1247, yend=1247,
color="firebrick",
linetype="longdash"))+
geom_segment(aes(x=1248, xend=2490, y=2489, yend=2489,
color="firebrick",
linetype="longdash"))+
geom_segment(aes(x=1248, xend=1248, y=1, yend=1247,
color="firebrick",
linetype="longdash"))+
geom_point(aes(x=2490, y=2489,color="firebrick"))+
geom_point(aes(x=2490, y=0,color="firebrick"))+
geom_point(aes(x=1248, y=1247,color="firebrick"))+
geom_point(aes(x=0, y=1247,color="firebrick"))+
geom_point(aes(x=0, y=1,color="firebrick"))+
geom_point(aes(x=0, y=2,color="darkgoldenrod"))+
ylab("Number of Observations in Set")+
theme(legend.position = "none")
p
k[min.index.train]
k[max.index.train]
k[max.train]
